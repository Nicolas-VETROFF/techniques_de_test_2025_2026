# Retour d'expérience

Lors de ce TP, j’ai d’abord dû me familiariser avec l’environnement Python ainsi qu’avec plusieurs outils associés, notamment Flask, Pytest, Coverage et Pdoc3. La démarche adoptée reposait sur la méthode TDD (Test Driven Development), consistant à concevoir et exécuter des tests avant même l’implémentation de l’application.

L’une des principales difficultés rencontrées concernait la conception des tests sans disposer d’une vision précise de l’implémentation finale. Cet exercice s’est révélé compliqué, car il va à l’encontre de l’approche habituelle qui consiste à coder avant de réfléchir aux tests unitaires. L'approche que nous n'avons cessé d'avoir depuis le début de notre scolarité en informatique (projets, TP, etc...) - du moins, pour ma part. Il était en effet difficile d’anticiper l’ensemble des comportements attendus sans avoir encore développé la logique.

Malgré l’application de cette méthode, j’ai constaté que certains cas d’erreur évidents n’avaient pas été pris en compte lors de l’écriture initiale des tests. Ces oublis ont été corrigés par la suite, une fois l’implémentation entamée, ce qui montre que la conception exhaustive des tests dès le départ reste un exercice difficile.

Par ailleurs, j’ai rencontré des difficultés dans la compréhension et l’utilisation du mécanisme de mock en Python. Son rôle et son intégration dans les tests n’étaient pas immédiatement clairs. Bien que j'ai pu utiliser des ressources similaires en JAVA lors de mes années à l'IUT. De plus, la définition de seuils pertinents pour les tests de performance s’est avérée aussi très difficile, en particulier pour des ensembles de points de taille moyenne ou importante à trianguler. Les valeurs retenues pour 1000 et 10 000 points ont donc été choisies de manière arbitraire, faute de références précises.

Néanmoins, cette expérience m’a permis de constater les bénéfices concrets du TDD. Le fait de rédiger les tests avant toute implémentation s’est révélé très utile pour garantir le bon fonctionnement du code par la suite. Cette approche permet également de limiter les biais liés à l’implémentation préalable, qui conduit souvent à négliger les cas limites et les scénarios d’erreur. En TDD, l’objectif initial n’est pas de faire passer les tests immédiatement, mais de s’assurer qu’ils couvrent correctement les comportements attendus, ce qui améliore la qualité globale de l’application.